export class AudioManager {\n    constructor() {\n        this.audioContext = null;\n        this.sounds = new Map();\n        this.music = new Map();\n        this.currentMusic = null;\n        \n        // Audio settings\n        this.masterVolume = 1.0;\n        this.musicVolume = 0.7;\n        this.sfxVolume = 0.8;\n        this.muted = false;\n        \n        // Audio nodes\n        this.masterGain = null;\n        this.musicGain = null;\n        this.sfxGain = null;\n        \n        // Audio loading\n        this.loadedSounds = new Set();\n        this.loadingPromises = new Map();\n        \n        this.initialize();\n    }\n    \n    initialize() {\n        try {\n            // Create audio context\n            const AudioContext = window.AudioContext || window.webkitAudioContext;\n            this.audioContext = new AudioContext();\n            \n            // Create gain nodes for volume control\n            this.masterGain = this.audioContext.createGain();\n            this.musicGain = this.audioContext.createGain();\n            this.sfxGain = this.audioContext.createGain();\n            \n            // Connect gain nodes\n            this.musicGain.connect(this.masterGain);\n            this.sfxGain.connect(this.masterGain);\n            this.masterGain.connect(this.audioContext.destination);\n            \n            // Set initial volumes\n            this.updateVolumes();\n            \n            console.log('🔊 Audio system initialized');\n            \n            // Handle page visibility change to pause/resume audio\n            document.addEventListener('visibilitychange', () => {\n                if (document.hidden) {\n                    this.pauseAll();\n                } else {\n                    this.resumeAll();\n                }\n            });\n            \n        } catch (error) {\n            console.error('❌ Failed to initialize audio system:', error);\n        }\n    }\n    \n    async loadSound(name, url, isMusic = false) {\n        if (this.loadingPromises.has(name)) {\n            return this.loadingPromises.get(name);\n        }\n        \n        const loadPromise = this.loadAudioFile(url).then(audioBuffer => {\n            const soundData = {\n                buffer: audioBuffer,\n                isMusic: isMusic,\n                instances: []\n            };\n            \n            if (isMusic) {\n                this.music.set(name, soundData);\n            } else {\n                this.sounds.set(name, soundData);\n            }\n            \n            this.loadedSounds.add(name);\n            console.log(`🎵 Loaded ${isMusic ? 'music' : 'sound'}: ${name}`);\n            \n            return soundData;\n        }).catch(error => {\n            console.error(`❌ Failed to load ${isMusic ? 'music' : 'sound'} ${name}:`, error);\n            throw error;\n        });\n        \n        this.loadingPromises.set(name, loadPromise);\n        return loadPromise;\n    }\n    \n    async loadAudioFile(url) {\n        const response = await fetch(url);\n        const arrayBuffer = await response.arrayBuffer();\n        return this.audioContext.decodeAudioData(arrayBuffer);\n    }\n    \n    // Load default game sounds\n    async loadGameSounds() {\n        const soundUrls = {\n            // Character sounds\n            jump: '/assets/audio/jump.ogg',\n            land: '/assets/audio/land.ogg',\n            hurt: '/assets/audio/hurt.ogg',\n            attack: '/assets/audio/attack.ogg',\n            special: '/assets/audio/special.ogg',\n            \n            // UI sounds\n            select: '/assets/audio/select.ogg',\n            confirm: '/assets/audio/confirm.ogg',\n            cancel: '/assets/audio/cancel.ogg',\n            menuMove: '/assets/audio/menu_move.ogg',\n            \n            // Game sounds\n            gameStart: '/assets/audio/game_start.ogg',\n            gameOver: '/assets/audio/game_over.ogg',\n            victory: '/assets/audio/victory.ogg',\n            hit: '/assets/audio/hit.ogg',\n            block: '/assets/audio/block.ogg',\n            explosion: '/assets/audio/explosion.ogg'\n        };\n        \n        const musicUrls = {\n            menu: '/assets/audio/menu_music.ogg',\n            gameplay: '/assets/audio/gameplay_music.ogg',\n            victory: '/assets/audio/victory_music.ogg'\n        };\n        \n        // Load sound effects\n        const soundPromises = Object.entries(soundUrls).map(([name, url]) => \n            this.loadSound(name, url, false).catch(error => {\n                console.warn(`Failed to load sound ${name}, using silence`);\n                return this.createSilentSound(name);\n            })\n        );\n        \n        // Load music\n        const musicPromises = Object.entries(musicUrls).map(([name, url]) => \n            this.loadSound(name, url, true).catch(error => {\n                console.warn(`Failed to load music ${name}, using silence`);\n                return this.createSilentSound(name, true);\n            })\n        );\n        \n        await Promise.all([...soundPromises, ...musicPromises]);\n        console.log('🎵 All game audio loaded');\n    }\n    \n    createSilentSound(name, isMusic = false) {\n        // Create a 1-second silent audio buffer as fallback\n        const buffer = this.audioContext.createBuffer(1, this.audioContext.sampleRate, this.audioContext.sampleRate);\n        const soundData = {\n            buffer: buffer,\n            isMusic: isMusic,\n            instances: []\n        };\n        \n        if (isMusic) {\n            this.music.set(name, soundData);\n        } else {\n            this.sounds.set(name, soundData);\n        }\n        \n        return soundData;\n    }\n    \n    playSound(name, options = {}) {\n        if (this.muted) return null;\n        \n        const soundData = this.sounds.get(name);\n        if (!soundData) {\n            console.warn(`Sound not found: ${name}`);\n            return null;\n        }\n        \n        const {\n            volume = 1.0,\n            pitch = 1.0,\n            loop = false,\n            delay = 0,\n            pan = 0\n        } = options;\n        \n        // Create audio source\n        const source = this.audioContext.createBufferSource();\n        source.buffer = soundData.buffer;\n        source.loop = loop;\n        source.playbackRate.value = pitch;\n        \n        // Create gain node for this instance\n        const gainNode = this.audioContext.createGain();\n        gainNode.gain.value = volume;\n        \n        // Create panner for 3D audio\n        const pannerNode = this.audioContext.createStereoPanner();\n        pannerNode.pan.value = Math.max(-1, Math.min(1, pan));\n        \n        // Connect nodes\n        source.connect(gainNode);\n        gainNode.connect(pannerNode);\n        pannerNode.connect(this.sfxGain);\n        \n        // Store instance for cleanup\n        const instance = {\n            source,\n            gainNode,\n            pannerNode,\n            startTime: this.audioContext.currentTime + delay,\n            volume\n        };\n        \n        soundData.instances.push(instance);\n        \n        // Clean up when sound ends\n        source.onended = () => {\n            const index = soundData.instances.indexOf(instance);\n            if (index > -1) {\n                soundData.instances.splice(index, 1);\n            }\n        };\n        \n        // Start playback\n        source.start(this.audioContext.currentTime + delay);\n        \n        return instance;\n    }\n    \n    playMusic(name, options = {}) {\n        if (this.muted) return;\n        \n        const musicData = this.music.get(name);\n        if (!musicData) {\n            console.warn(`Music not found: ${name}`);\n            return;\n        }\n        \n        // Stop current music\n        this.stopMusic();\n        \n        const {\n            volume = 1.0,\n            fadeIn = 1.0,\n            loop = true\n        } = options;\n        \n        // Create audio source\n        const source = this.audioContext.createBufferSource();\n        source.buffer = musicData.buffer;\n        source.loop = loop;\n        \n        // Create gain node for fade effects\n        const gainNode = this.audioContext.createGain();\n        gainNode.gain.value = fadeIn > 0 ? 0 : volume;\n        \n        // Connect nodes\n        source.connect(gainNode);\n        gainNode.connect(this.musicGain);\n        \n        // Store current music info\n        this.currentMusic = {\n            name,\n            source,\n            gainNode,\n            volume,\n            startTime: this.audioContext.currentTime\n        };\n        \n        // Fade in if specified\n        if (fadeIn > 0) {\n            gainNode.gain.linearRampToValueAtTime(volume, this.audioContext.currentTime + fadeIn);\n        }\n        \n        // Start playback\n        source.start();\n        \n        console.log(`🎵 Playing music: ${name}`);\n    }\n    \n    stopMusic(fadeOut = 0.5) {\n        if (!this.currentMusic) return;\n        \n        if (fadeOut > 0) {\n            // Fade out\n            this.currentMusic.gainNode.gain.linearRampToValueAtTime(0, this.audioContext.currentTime + fadeOut);\n            setTimeout(() => {\n                if (this.currentMusic) {\n                    this.currentMusic.source.stop();\n                    this.currentMusic = null;\n                }\n            }, fadeOut * 1000);\n        } else {\n            // Stop immediately\n            this.currentMusic.source.stop();\n            this.currentMusic = null;\n        }\n    }\n    \n    pauseMusic() {\n        if (this.currentMusic) {\n            this.currentMusic.source.suspend();\n        }\n    }\n    \n    resumeMusic() {\n        if (this.currentMusic) {\n            this.currentMusic.source.resume();\n        }\n    }\n    \n    stopSound(name) {\n        const soundData = this.sounds.get(name);\n        if (!soundData) return;\n        \n        soundData.instances.forEach(instance => {\n            instance.source.stop();\n        });\n        soundData.instances = [];\n    }\n    \n    stopAllSounds() {\n        this.sounds.forEach(soundData => {\n            soundData.instances.forEach(instance => {\n                instance.source.stop();\n            });\n            soundData.instances = [];\n        });\n    }\n    \n    pauseAll() {\n        if (this.audioContext.state === 'running') {\n            this.audioContext.suspend();\n        }\n    }\n    \n    resumeAll() {\n        if (this.audioContext.state === 'suspended') {\n            this.audioContext.resume();\n        }\n    }\n    \n    // Volume controls\n    setMasterVolume(volume) {\n        this.masterVolume = Math.max(0, Math.min(1, volume));\n        this.updateVolumes();\n    }\n    \n    setMusicVolume(volume) {\n        this.musicVolume = Math.max(0, Math.min(1, volume));\n        this.updateVolumes();\n    }\n    \n    setSfxVolume(volume) {\n        this.sfxVolume = Math.max(0, Math.min(1, volume));\n        this.updateVolumes();\n    }\n    \n    updateVolumes() {\n        if (this.masterGain) {\n            this.masterGain.gain.value = this.muted ? 0 : this.masterVolume;\n        }\n        if (this.musicGain) {\n            this.musicGain.gain.value = this.musicVolume;\n        }\n        if (this.sfxGain) {\n            this.sfxGain.gain.value = this.sfxVolume;\n        }\n    }\n    \n    mute() {\n        this.muted = true;\n        this.updateVolumes();\n    }\n    \n    unmute() {\n        this.muted = false;\n        this.updateVolumes();\n    }\n    \n    toggleMute() {\n        this.muted = !this.muted;\n        this.updateVolumes();\n    }\n    \n    isMuted() {\n        return this.muted;\n    }\n    \n    // Audio effects\n    playRandomSound(sounds, options = {}) {\n        if (sounds.length === 0) return;\n        const randomSound = sounds[Math.floor(Math.random() * sounds.length)];\n        return this.playSound(randomSound, options);\n    }\n    \n    play3DSound(name, x, y, listenerX, listenerY, options = {}) {\n        const distance = Math.sqrt((x - listenerX) ** 2 + (y - listenerY) ** 2);\n        const maxDistance = options.maxDistance || 500;\n        \n        // Calculate volume based on distance\n        const volume = Math.max(0, 1 - distance / maxDistance) * (options.volume || 1);\n        \n        // Calculate pan based on position\n        const pan = Math.max(-1, Math.min(1, (x - listenerX) / maxDistance));\n        \n        return this.playSound(name, {\n            ...options,\n            volume,\n            pan\n        });\n    }\n    \n    // Audio visualization\n    createAnalyser() {\n        const analyser = this.audioContext.createAnalyser();\n        analyser.fftSize = 256;\n        this.masterGain.connect(analyser);\n        return analyser;\n    }\n    \n    // Character-specific sound methods\n    playCharacterSound(characterName, soundType, options = {}) {\n        const soundName = `${characterName}_${soundType}`;\n        return this.playSound(soundName, options);\n    }\n    \n    playBlueySound(soundType, options = {}) {\n        return this.playCharacterSound('bluey', soundType, options);\n    }\n    \n    playBingoSound(soundType, options = {}) {\n        return this.playCharacterSound('bingo', soundType, options);\n    }\n    \n    // Game event sounds\n    playMenuSound(action) {\n        const soundMap = {\n            navigate: 'menuMove',\n            select: 'select',\n            confirm: 'confirm',\n            back: 'cancel'\n        };\n        \n        const soundName = soundMap[action];\n        if (soundName) {\n            this.playSound(soundName);\n        }\n    }\n    \n    playGameSound(event, options = {}) {\n        const soundMap = {\n            gameStart: 'gameStart',\n            gameOver: 'gameOver',\n            victory: 'victory',\n            hit: 'hit',\n            block: 'block',\n            jump: 'jump',\n            land: 'land',\n            hurt: 'hurt',\n            attack: 'attack',\n            special: 'special',\n            explosion: 'explosion'\n        };\n        \n        const soundName = soundMap[event];\n        if (soundName) {\n            this.playSound(soundName, options);\n        }\n    }\n    \n    // Settings persistence\n    saveSettings() {\n        const settings = {\n            masterVolume: this.masterVolume,\n            musicVolume: this.musicVolume,\n            sfxVolume: this.sfxVolume,\n            muted: this.muted\n        };\n        \n        localStorage.setItem('bluey-smash-audio', JSON.stringify(settings));\n    }\n    \n    loadSettings() {\n        try {\n            const saved = localStorage.getItem('bluey-smash-audio');\n            if (saved) {\n                const settings = JSON.parse(saved);\n                this.masterVolume = settings.masterVolume ?? 1.0;\n                this.musicVolume = settings.musicVolume ?? 0.7;\n                this.sfxVolume = settings.sfxVolume ?? 0.8;\n                this.muted = settings.muted ?? false;\n                this.updateVolumes();\n                console.log('🔊 Audio settings loaded');\n            }\n        } catch (error) {\n            console.warn('Failed to load audio settings:', error);\n        }\n    }\n    \n    // Statistics\n    getAudioStats() {\n        return {\n            loadedSounds: this.loadedSounds.size,\n            activeSounds: Array.from(this.sounds.values()).reduce((total, sound) => \n                total + sound.instances.length, 0),\n            currentMusic: this.currentMusic?.name || null,\n            masterVolume: this.masterVolume,\n            musicVolume: this.musicVolume,\n            sfxVolume: this.sfxVolume,\n            muted: this.muted,\n            audioContext: this.audioContext?.state\n        };\n    }\n    \n    // Cleanup\n    destroy() {\n        this.stopAllSounds();\n        this.stopMusic(0);\n        \n        if (this.audioContext) {\n            this.audioContext.close();\n        }\n        \n        this.sounds.clear();\n        this.music.clear();\n        this.loadingPromises.clear();\n        this.loadedSounds.clear();\n        \n        console.log('🔊 Audio system destroyed');\n    }\n}