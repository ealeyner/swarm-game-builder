export class Character {\n    constructor(options) {\n        // Basic properties\n        this.id = options.id;\n        this.name = options.name;\n        this.type = 'character';\n        \n        // Position and dimensions\n        this.x = options.x || 0;\n        this.y = options.y || 0;\n        this.width = options.width || 48;\n        this.height = options.height || 64;\n        \n        // Physics properties\n        this.vx = 0;\n        this.vy = 0;\n        this.maxSpeed = 8;\n        this.acceleration = 0.8;\n        this.jumpPower = 15;\n        this.isGrounded = false;\n        this.hasPhysics = true;\n        this.affectedByGravity = true;\n        \n        // Visual properties\n        this.color = options.color || '#4169E1';\n        this.facing = 1; // 1 = right, -1 = left\n        this.sprite = null;\n        this.animationFrame = 0;\n        this.animationSpeed = 0.2;\n        \n        // Health and damage\n        this.health = 100;\n        this.maxHealth = 100;\n        this.damage = 10;\n        this.isKnockedOut = false;\n        this.invulnerable = false;\n        this.invulnerabilityTime = 0;\n        \n        // Combat properties\n        this.attackPower = 15;\n        this.specialPower = 25;\n        this.knockback = 5;\n        this.isAttacking = false;\n        this.attackCooldown = 0;\n        this.specialCooldown = 0;\n        \n        // Input mapping\n        this.controls = options.controls || {};\n        this.inputBuffer = [];\n        this.lastInputTime = 0;\n        \n        // States\n        this.state = 'idle';\n        this.previousState = 'idle';\n        this.stateTime = 0;\n        this.canMove = true;\n        this.canJump = true;\n        this.canAttack = true;\n        \n        // Effects\n        this.hitStun = 0;\n        this.knockbackX = 0;\n        this.knockbackY = 0;\n        this.blinkTime = 0;\n        \n        // Bluey-specific properties\n        this.characterType = this.name.toLowerCase();\n        this.setupCharacterStats();\n        \n        // Bounds calculation\n        this.updateBounds();\n        \n        console.log(`👤 Created character: ${this.name}`);\n    }\n    \n    setupCharacterStats() {\n        // Character-specific stats and abilities\n        switch(this.characterType) {\n            case 'bluey':\n                this.maxSpeed = 8;\n                this.jumpPower = 15;\n                this.attackPower = 15;\n                this.specialPower = 25;\n                this.specialAbility = 'energy_burst';\n                break;\n                \n            case 'bingo':\n                this.maxSpeed = 9;\n                this.jumpPower = 16;\n                this.attackPower = 12;\n                this.specialPower = 30;\n                this.specialAbility = 'spin_attack';\n                break;\n                \n            default:\n                // Default stats\n                this.specialAbility = 'basic_attack';\n        }\n    }\n    \n    update(deltaTime) {\n        const dt = deltaTime / 16.67; // Normalize to 60 FPS\n        \n        // Update state time\n        this.stateTime += deltaTime;\n        \n        // Update cooldowns\n        this.updateCooldowns(dt);\n        \n        // Update effects\n        this.updateEffects(dt);\n        \n        // Update state machine\n        this.updateState(dt);\n        \n        // Update animation\n        this.updateAnimation(dt);\n        \n        // Update bounds\n        this.updateBounds();\n        \n        // Clear input buffer periodically\n        this.cleanInputBuffer();\n    }\n    \n    updateCooldowns(deltaTime) {\n        if (this.attackCooldown > 0) {\n            this.attackCooldown -= deltaTime;\n        }\n        \n        if (this.specialCooldown > 0) {\n            this.specialCooldown -= deltaTime;\n        }\n        \n        if (this.invulnerabilityTime > 0) {\n            this.invulnerabilityTime -= deltaTime;\n            this.invulnerable = this.invulnerabilityTime > 0;\n        }\n        \n        if (this.hitStun > 0) {\n            this.hitStun -= deltaTime;\n            this.canMove = this.hitStun <= 0;\n            this.canAttack = this.hitStun <= 0;\n        }\n        \n        if (this.blinkTime > 0) {\n            this.blinkTime -= deltaTime;\n        }\n    }\n    \n    updateEffects(deltaTime) {\n        // Apply knockback\n        if (this.knockbackX !== 0 || this.knockbackY !== 0) {\n            this.vx += this.knockbackX;\n            this.vy += this.knockbackY;\n            \n            // Reduce knockback over time\n            this.knockbackX *= 0.9;\n            this.knockbackY *= 0.9;\n            \n            // Clear small knockback values\n            if (Math.abs(this.knockbackX) < 0.1) this.knockbackX = 0;\n            if (Math.abs(this.knockbackY) < 0.1) this.knockbackY = 0;\n        }\n    }\n    \n    updateState(deltaTime) {\n        const previousState = this.state;\n        \n        // State transitions based on conditions\n        if (this.isKnockedOut) {\n            this.setState('knocked_out');\n        } else if (this.hitStun > 0) {\n            this.setState('hit_stun');\n        } else if (this.isAttacking) {\n            this.setState('attacking');\n        } else if (!this.isGrounded) {\n            if (this.vy < 0) {\n                this.setState('jumping');\n            } else {\n                this.setState('falling');\n            }\n        } else if (Math.abs(this.vx) > 0.5) {\n            this.setState('running');\n        } else {\n            this.setState('idle');\n        }\n        \n        // State-specific behavior\n        switch(this.state) {\n            case 'idle':\n                this.handleIdleState(deltaTime);\n                break;\n            case 'running':\n                this.handleRunningState(deltaTime);\n                break;\n            case 'jumping':\n                this.handleJumpingState(deltaTime);\n                break;\n            case 'falling':\n                this.handleFallingState(deltaTime);\n                break;\n            case 'attacking':\n                this.handleAttackingState(deltaTime);\n                break;\n            case 'hit_stun':\n                this.handleHitStunState(deltaTime);\n                break;\n            case 'knocked_out':\n                this.handleKnockedOutState(deltaTime);\n                break;\n        }\n    }\n    \n    setState(newState) {\n        if (this.state !== newState) {\n            this.previousState = this.state;\n            this.state = newState;\n            this.stateTime = 0;\n            this.onStateEnter(newState);\n        }\n    }\n    \n    onStateEnter(state) {\n        switch(state) {\n            case 'attacking':\n                this.canMove = false;\n                this.canJump = false;\n                break;\n            case 'hit_stun':\n                this.canMove = false;\n                this.canAttack = false;\n                this.canJump = false;\n                break;\n            case 'knocked_out':\n                this.canMove = false;\n                this.canAttack = false;\n                this.canJump = false;\n                this.vx = 0;\n                break;\n            default:\n                this.canMove = true;\n                this.canJump = true;\n                this.canAttack = true;\n        }\n    }\n    \n    handleIdleState(deltaTime) {\n        // Gradually reduce horizontal velocity\n        this.vx *= 0.8;\n    }\n    \n    handleRunningState(deltaTime) {\n        // Update facing direction\n        if (this.vx > 0) {\n            this.facing = 1;\n        } else if (this.vx < 0) {\n            this.facing = -1;\n        }\n    }\n    \n    handleJumpingState(deltaTime) {\n        // Allow air control\n        this.vx *= 0.98;\n    }\n    \n    handleFallingState(deltaTime) {\n        // Allow air control\n        this.vx *= 0.98;\n    }\n    \n    handleAttackingState(deltaTime) {\n        // Attack duration\n        if (this.stateTime > 300) { // 300ms attack\n            this.isAttacking = false;\n            this.attackCooldown = 500; // 500ms cooldown\n        }\n    }\n    \n    handleHitStunState(deltaTime) {\n        // Character is stunned, can't act\n    }\n    \n    handleKnockedOutState(deltaTime) {\n        // Character is defeated\n    }\n    \n    updateAnimation(deltaTime) {\n        this.animationFrame += this.animationSpeed * (deltaTime / 16.67);\n        \n        // Different frame counts for different states\n        let maxFrames = 1;\n        switch(this.state) {\n            case 'idle':\n                maxFrames = 4;\n                break;\n            case 'running':\n                maxFrames = 6;\n                break;\n            case 'jumping':\n                maxFrames = 2;\n                break;\n            case 'attacking':\n                maxFrames = 3;\n                break;\n        }\n        \n        if (this.animationFrame >= maxFrames) {\n            this.animationFrame = 0;\n        }\n    }\n    \n    handleInput(inputManager) {\n        if (!this.canMove && !this.canAttack) return;\n        \n        const input = inputManager.getPlayerInput(this.id, this.controls);\n        \n        // Store input in buffer for combo detection\n        this.addInputToBuffer(input);\n        \n        // Movement\n        if (this.canMove) {\n            this.handleMovementInput(input);\n        }\n        \n        // Actions\n        if (this.canAttack) {\n            this.handleActionInput(input);\n        }\n    }\n    \n    handleMovementInput(input) {\n        // Horizontal movement\n        if (input.left) {\n            this.vx -= this.acceleration;\n            this.vx = Math.max(this.vx, -this.maxSpeed);\n        }\n        \n        if (input.right) {\n            this.vx += this.acceleration;\n            this.vx = Math.min(this.vx, this.maxSpeed);\n        }\n        \n        // Jumping\n        if (input.upPressed && this.canJump && this.isGrounded) {\n            this.vy = -this.jumpPower;\n            this.isGrounded = false;\n        }\n    }\n    \n    handleActionInput(input) {\n        // Basic attack\n        if (input.attackPressed && this.attackCooldown <= 0) {\n            this.performAttack();\n        }\n        \n        // Special attack\n        if (input.specialPressed && this.specialCooldown <= 0) {\n            this.performSpecialAttack();\n        }\n    }\n    \n    performAttack() {\n        this.isAttacking = true;\n        this.attackCooldown = 500; // 500ms cooldown\n        \n        console.log(`⚔️ ${this.name} attacks!`);\n        \n        // Create attack hitbox\n        this.createAttackHitbox();\n    }\n    \n    performSpecialAttack() {\n        this.specialCooldown = 2000; // 2 second cooldown\n        \n        console.log(`✨ ${this.name} uses special attack: ${this.specialAbility}!`);\n        \n        switch(this.specialAbility) {\n            case 'energy_burst':\n                this.energyBurstAttack();\n                break;\n            case 'spin_attack':\n                this.spinAttack();\n                break;\n            default:\n                this.performAttack();\n        }\n    }\n    \n    energyBurstAttack() {\n        // Bluey's special - energy projectile\n        const projectile = {\n            x: this.x + (this.facing > 0 ? this.width : -20),\n            y: this.y + this.height / 2,\n            width: 20,\n            height: 20,\n            vx: this.facing * 12,\n            vy: 0,\n            damage: this.specialPower,\n            owner: this,\n            type: 'projectile',\n            color: '#00BFFF',\n            lifeTime: 2000\n        };\n        \n        // This would be added to the game's projectile array\n        this.onProjectileCreated?.(projectile);\n    }\n    \n    spinAttack() {\n        // Bingo's special - spinning area attack\n        this.isAttacking = true;\n        this.attackCooldown = 1000;\n        \n        // Create larger hitbox around character\n        const hitbox = {\n            x: this.x - 30,\n            y: this.y - 30,\n            width: this.width + 60,\n            height: this.height + 60,\n            damage: this.specialPower,\n            knockback: this.knockback * 2,\n            owner: this\n        };\n        \n        // This would be processed by the game's collision system\n        this.onAttackCreated?.(hitbox);\n    }\n    \n    createAttackHitbox() {\n        const hitbox = {\n            x: this.x + (this.facing > 0 ? this.width : -40),\n            y: this.y,\n            width: 40,\n            height: this.height,\n            damage: this.attackPower,\n            knockback: this.knockback,\n            owner: this\n        };\n        \n        // This would be processed by the game's collision system\n        this.onAttackCreated?.(hitbox);\n    }\n    \n    takeDamage(damage, attacker = null) {\n        if (this.invulnerable || this.isKnockedOut) return false;\n        \n        this.health -= damage;\n        this.health = Math.max(0, this.health);\n        \n        // Apply hit effects\n        this.hitStun = 200; // 200ms hit stun\n        this.invulnerabilityTime = 1000; // 1 second invulnerability\n        this.blinkTime = 1000; // Blink during invulnerability\n        \n        console.log(`💔 ${this.name} takes ${damage} damage (${this.health}/${this.maxHealth})`);\n        \n        // Check for knockout\n        if (this.health <= 0) {\n            this.isKnockedOut = true;\n            console.log(`💀 ${this.name} is knocked out!`);\n        }\n        \n        return true;\n    }\n    \n    heal(amount) {\n        this.health += amount;\n        this.health = Math.min(this.maxHealth, this.health);\n        console.log(`💚 ${this.name} heals ${amount} HP (${this.health}/${this.maxHealth})`);\n    }\n    \n    applyKnockback(forceX, forceY) {\n        this.knockbackX += forceX;\n        this.knockbackY += forceY;\n    }\n    \n    addInputToBuffer(input) {\n        const now = Date.now();\n        this.inputBuffer.push({\n            input: { ...input },\n            timestamp: now\n        });\n        \n        // Keep buffer size manageable\n        if (this.inputBuffer.length > 10) {\n            this.inputBuffer.shift();\n        }\n    }\n    \n    cleanInputBuffer() {\n        const now = Date.now();\n        this.inputBuffer = this.inputBuffer.filter(entry => \n            now - entry.timestamp < 1000 // Keep inputs from last second\n        );\n    }\n    \n    // Check for input combos\n    checkCombo(pattern) {\n        // This could be expanded to detect input combinations\n        // For now, just a placeholder\n        return false;\n    }\n    \n    updateBounds() {\n        this.left = this.x;\n        this.right = this.x + this.width;\n        this.top = this.y;\n        this.bottom = this.y + this.height;\n        this.centerX = this.x + this.width / 2;\n        this.centerY = this.y + this.height / 2;\n    }\n    \n    render(renderer) {\n        // Don't render if blinking and should be invisible\n        if (this.blinkTime > 0 && Math.floor(this.blinkTime / 100) % 2 === 0) {\n            return;\n        }\n        \n        // Render character using the renderer's character drawing method\n        renderer.drawCharacter(this);\n        \n        // Render debug info if needed\n        if (renderer.debugMode) {\n            this.renderDebug(renderer);\n        }\n    }\n    \n    renderDebug(renderer) {\n        // Render state text\n        renderer.drawText(`${this.name}: ${this.state}`, \n            this.x, this.y - 40, '12px Arial', '#FFF');\n        \n        // Render velocity\n        renderer.drawText(`vx:${this.vx.toFixed(1)} vy:${this.vy.toFixed(1)}`, \n            this.x, this.y - 25, '10px Arial', '#FFF');\n        \n        // Render health\n        renderer.drawText(`HP: ${this.health}/${this.maxHealth}`, \n            this.x, this.y - 10, '10px Arial', '#FFF');\n    }\n    \n    // Network synchronization\n    getNetworkData() {\n        return {\n            id: this.id,\n            x: this.x,\n            y: this.y,\n            vx: this.vx,\n            vy: this.vy,\n            health: this.health,\n            facing: this.facing,\n            state: this.state,\n            isGrounded: this.isGrounded,\n            isAttacking: this.isAttacking,\n            animationFrame: this.animationFrame\n        };\n    }\n    \n    applyNetworkData(data) {\n        // Apply remote player data with interpolation\n        this.x = data.x;\n        this.y = data.y;\n        this.vx = data.vx;\n        this.vy = data.vy;\n        this.health = data.health;\n        this.facing = data.facing;\n        this.state = data.state;\n        this.isGrounded = data.isGrounded;\n        this.isAttacking = data.isAttacking;\n        this.animationFrame = data.animationFrame;\n        \n        this.updateBounds();\n    }\n    \n    reset() {\n        // Reset character to initial state\n        this.health = this.maxHealth;\n        this.isKnockedOut = false;\n        this.vx = 0;\n        this.vy = 0;\n        this.state = 'idle';\n        this.isGrounded = false;\n        this.isAttacking = false;\n        this.attackCooldown = 0;\n        this.specialCooldown = 0;\n        this.invulnerable = false;\n        this.invulnerabilityTime = 0;\n        this.hitStun = 0;\n        this.blinkTime = 0;\n        this.knockbackX = 0;\n        this.knockbackY = 0;\n        this.facing = 1;\n        this.animationFrame = 0;\n        \n        console.log(`🔄 ${this.name} reset`);\n    }\n    \n    // Character-specific methods that can be overridden\n    getDisplayName() {\n        return this.name;\n    }\n    \n    getCharacterColor() {\n        return this.color;\n    }\n    \n    canPerformSpecial() {\n        return this.specialCooldown <= 0 && this.canAttack;\n    }\n    \n    getSpecialCooldownPercent() {\n        return Math.max(0, this.specialCooldown / 2000);\n    }\n}